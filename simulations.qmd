---
title: "Ctsem Simulations"
format: html
editor: source
---

```{r}
library(ctsem)
library(expm)
set.seed(16917042)
```

## Model with 2 latent processes
### Simulated data

- 200 time points
- N = 1
- 2 latent processes


```{r}
# compute drift matrix from discrete time effects with a time interval of 1
delta_t <- 1
drift_matrix_1 <- expm::logm(matrix(c(0.8, 0.2, 0.15, 0.7), nrow = 2)) / delta_t
rel <- 1
 
# model to simulate data
generating_model_1 <- ctModel(Tpoints = 200, n.latent = 2, n.TDpred = 0, n.TIpred = 0, n.manifest = 2,
                              LAMBDA = diag(1, 2),
                              MANIFESTVAR = diag(0, 2),
                              MANIFESTMEANS = matrix(0, ncol = 1, nrow = 2),
                              DRIFT = drift_matrix_1,
                              #TRAITVAR = matrix(c(0.5, 0.2, 0, 0.8), nrow=2), # erst bei n > 1
                              DIFFUSION = matrix(c(0.5, 0.2, 0, 0.4), nrow = 2),
                              T0MEANS = matrix(1, ncol = 1, nrow = 2),
                              T0VAR = diag(0.1, 2)
                              )
```


```{r}
data_1 <- ctGenerate(generating_model_1, n.subjects = 1, burnin = 100, dtmean = 0.15, logdtsd = .1)
```


### Model specification

```{r}
model_1 <- ctModel(type = "stanct",
                   n.latent = 2, latentNames=c('symptom_severity','avoidance'),
                   n.manifest = 2, manifestNames=c('Y1','Y2'),
                   LAMBDA=diag(2))
model_1$pars$indvarying <- FALSE
#ctModelLatex(model_1)
```

```{r}
head(model_1$pars)
```

### Model fitting

```{r}
fit_1 <- ctStanFit(datalong = data_1, ctstanmodel = model_1, priors = FALSE, optimize = TRUE) 
# priors: True -> HMC, false -> max likelihood
```




### Summary and plots

```{r}
summary(fit_1)

summary(fit_1)$popmeans

ctCI(fit_1, confidenceintervals = "DRIFT")

ctStanContinuousPars(fit_1, calcfunc = quantile,
  calcfuncargs = list(probs = 0.5))$DRIFT[1,1]
```

```{r}
plot(fit)
```

```{r}
ctStanDiscretePars(fit, plot = TRUE, # regression coefficient for particular time intervals
                   indices = 'CR') # cross effects (AR would be auto effects)

#ctStanPlotPost(obj = fit, rows = 3) # posterior vs prior

ctKalman(fit, subjects = 1,
         timerange = c(0,10),
         timestep = 3,
         kalmanvec = c('y', 'etaprior'), 
         plot = TRUE, 
         plotcontrol = list(xaxs = 'i', main = "Predicted"))
```
## 

```{r}
sim_ctsem <- function(n_sims, n_subjects, n_tpoints, alpha = 0.05){
  
  # Initialize results data frame
  drift_results <- data.frame(iter = integer(),
                              drift_symptom_severity = numeric(),
                              drift_symptom_severity_lower = numeric(),
                              drift_symptom_severity_upper = numeric(),
                              drift_symptom_severity_significance = numeric(),
                              drift_symptom_severity_avoidance = numeric(),
                              drift_symptom_severity_avoidance_lower = numeric(),
                              drift_symptom_severity_avoidance_upper = numeric(),
                              drift_symptom_severity_avoidance_significance = numeric(),
                              drift_avoidance_symptom_severity = numeric(),
                              drift_avoidance_symptom_severity_lower = numeric(),
                              drift_avoidance_symptom_severity_upper = numeric(),
                              drift_avoidance_symptom_severity_significance = numeric(),
                              drift_avoidance = numeric(),
                              drift_avoidance_lower = numeric(),
                              drift_avoidance_upper = numeric(),
                              drift_avoidance_significance = numeric()
                              )
  
  # Generating model
  delta_t <- 1
  drift_matrix_true <- logm(matrix(c(0.8, 0.2, 0.15, 0.7), nrow = 2)) / delta_t
  generating_model_sim <- ctModel(Tpoints = n_tpoints, n.latent = 2, n.TDpred = 0, n.TIpred = 0, n.manifest = 2,
                                  LAMBDA = diag(1, 2),
                                  MANIFESTVAR = diag(0, 2),
                                  MANIFESTMEANS = matrix(0, ncol = 1, nrow = 2),
                                  DRIFT = drift_matrix_true,
                                  #TRAITVAR = matrix(c(0.5, 0.2, 0, 0.8), nrow=2), # erst bei n > 1
                                  DIFFUSION = matrix(c(0.5, 0.2, 0, 0.4), nrow = 2),
                                  T0MEANS = matrix(1, ncol = 1, nrow = 2),
                                  T0VAR = diag(0.1, 2)
                                  )
  
  # Loop 
  for (i in 1:n_sims) {
    
    tryCatch({
    
      # Generate data
      data_sim <- ctGenerate(generating_model_sim, n.subjects = n_subjects, burnin = 100, dtmean = 0.15, logdtsd = .1)
      
      # Model specification
      model_sim <- ctModel(type = "stanct",
                           n.latent = 2, latentNames=c('symptom_severity','avoidance'),
                           n.manifest = 2, manifestNames=c('Y1','Y2'),
                           LAMBDA=diag(2))
      model_sim$pars$indvarying <- FALSE
    
      # Model fitting
      fit_sim <- ctStanFit(datalong = data_sim, ctstanmodel = model_sim, priors = FALSE, optimize = TRUE) 

      # Drift matrix estimates
      drift_matrix <- summary(fit_sim)$parmatrices$DRIFT

      drift_results[i, ] <- c(i,
                              summary(fit_sim)$popmeans[3, 1], # Auto-effect of symptom severity
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = alpha/2))$DRIFT[1,1],
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = 1 - alpha/2))$DRIFT[1,1],
                              !(ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                     calcfuncargs = list(probs = 0.025))$DRIFT[1,1] <= 0 &
                                  ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                       calcfuncargs = list(probs = 0.975))$DRIFT[1,1] >= 0),
                              summary(fit_sim)$popmeans[4, 1], # Cross-effect from symptom severity to avoidance
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = alpha/2))$DRIFT[1,2],
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = 1 - alpha/2))$DRIFT[1,2],
                              summary(fit_sim)$popmeans[4, 1],
                              summary(fit_sim)$popmeans[5, 1], # Cross-effect from avoidance to symptom severity
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = alpha/2))$DRIFT[2,1],
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = 1 - alpha/2))$DRIFT[2,1],
                              summary(fit_sim)$popmeans[5, 1],
                              summary(fit_sim)$popmeans[6, 1],  # Auto-effect of avoidance
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = alpha/2))$DRIFT[2,2],
                              ctStanContinuousPars(fit_sim, calcfunc = quantile, 
                                                   calcfuncargs = list(probs = 1 - alpha/2))$DRIFT[2,2],
                              summary(fit_sim)$popmeans[6, 1]
                              )

      # Progress indicator
      if (i %% 50 == 0) {
        cat("Completed simulation", i, "of", n_sims, "\n")
      }

    }, error = function(e) {
      
      # Handle convergence failures
      cat("Simulation", i, "failed:", e$message, "\n")
      drift_results[i, 2:17] <- NA
    })
    
  }
  return(drift_results)
}

results_2 <- sim_ctsem(5, 1, 200)

summary(results[, 2:5])

```






## Model with 3 latent processes
### Model specification

```{r}
# compute drift matrix from discrete time effects with a time interval of 1
drift_matrix_2 <- logm(matrix(c(0.8, 0.1, 0.2, 0.25, 0.7, 0.15, 0.3, 0.25, 0.85), nrow = 3)) / delta_t

# model to simulate data
generating_model_2 <-ctModel(Tpoints = 200, n.latent = 3, n.TDpred = 0, n.TIpred = 0, n.manifest = 3,
                             MANIFESTVAR = diag(.1, 3),
                             LAMBDA = diag(1, 3),
                             MANIFESTVAR = diag(0, 2),
                             MANIFESTMEANS = matrix(0, ncol = 1, nrow = 2),
                             DRIFT = drift_matrix_2,
                             #TRAITVAR = matrix(c(.5, .2, .3, 0, .8, .1, 0, 0, .7), nrow=3),
                             DIFFUSION = matrix(c(0.5, 0.2, 0.3, 0, 0.4, 0.2, 0, 0, 0.5), nrow = 3),
                             #CINT = matrix(c(1, 0, 1), ncol = 1, nrow=3),
                             T0MEANS = matrix(1, ncol = 1, nrow = 3),
                             T0VAR = diag(0.1, 3),
                             #TIPREDMEANS = diag(0, 1),
                             #TIPREDVAR = diag(1, 1),
                             #TIPREDEFFECT = matrix(c(.1, .15, .1), ncol = 1, nrow=3)
                             )
```

```{r}
data_2 <- ctGenerate(generating_model_2, n.subjects = 1, burnin = 100, dtmean = .3, logdtsd = .1)
```

### Set up

```{r}
model_2 <- ctModel(type = "stanct",
                   n.latent = 3, latentNames=c('symptom_severity','avoidance', 'self_compassion'),
                   n.manifest = 3, manifestNames=c('Y1','Y2', 'Y3'),
                   #CINT = matrix(c('cint1', 'cint2', 'cint3'), nrow = 3, ncol = 1), #free cont intercept
                   #MANIFESTMEANS = matrix(c(0,0,0), nrow = 3), # fix manifest means to 0
                   LAMBDA=diag(3))
#ctModelLatex(model_1)
```

```{r}
head(model_2$pars)
```

### Model fitting

```{r}
fit_2 <- ctStanFit(datalong = data_2, ctstanmodel = model_2, priors = FALSE, optimize = TRUE) 
# priors: True -> HMC, false -> max likelihood
```

